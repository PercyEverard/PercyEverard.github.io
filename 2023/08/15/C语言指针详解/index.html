<!-- build time:Wed Aug 16 2023 00:06:06 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="fengyepiaosa" href="https://percyeverard.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="fengyepiaosa" href="https://percyeverard.github.io/atom.xml"><link rel="alternate" type="application/json" title="fengyepiaosa" href="https://percyeverard.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="reshipment,pointer,clanguage"><link rel="canonical" href="https://percyeverard.github.io/2023/08/15/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/"><title>C 语言指针详解 - 编程拓展 | Percy Feng = fengyepiaosa = Neuromancer</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">C 语言指针详解</h1><div class="meta"><span class="item" title="创建时间：2023-08-15 21:54:48"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-08-15T21:54:48+08:00">2023-08-15</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Percy Feng</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><img src="https://s2.loli.net/2023/08/15/rpEx3Lqw8AsRg24.png"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E7%BC%96%E7%A8%8B%E6%8B%93%E5%B1%95/" itemprop="item" rel="index" title="分类于 编程拓展"><span itemprop="name">编程拓展</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://percyeverard.github.io/2023/08/15/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/magic.png"><meta itemprop="name" content="Percy Everard"><meta itemprop="description" content="Neuromancer, Really start to record my life, no longer lazy!"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="fengyepiaosa"></span><div class="body md" itemprop="articleBody"><p>道哥在这篇文章中把 C 语言指针讲得非常透彻，感觉指针的全部用法都囊括其中🐮！读罢感慨万千，今年的雷军年度演讲上他说道：99% 的问题，都有标准答案，找个懂的人问问！能够搜寻到好的学习资料对我们这些初学者来说，便是莫大的帮助！</p><h1 id="一-前言"><a class="anchor" href="#一-前言">#</a> 一、前言</h1><p>如果问 C 语言中最重要、威力最大的概念是什么，答案必将是指针！威力大，意味着使用方便、高效，同时也意味着语法复杂、容易出错。指针用的好，可以极大的提高代码执行效率、节约系统资源；如果用的不好，程序中将会充满陷阱、漏洞。</p><p>这篇文章，我们就来聊聊指针。从最底层的内存存储空间开始，一直到应用层的各种指针使用技巧，循序渐进、抽丝剥茧，以最直白的语言进行讲解，让你一次看过瘾。</p><p>说明：为了方便讲解和理解，文中配图的内存空间的地址是随便写的，在实际计算机中是要遵循地址对齐方式的。</p><h1 id="二-变量与指针的本质"><a class="anchor" href="#二-变量与指针的本质">#</a> 二、变量与指针的本质</h1><h2 id="1-内存地址"><a class="anchor" href="#1-内存地址">#</a> 1. 内存地址</h2><p>我们编写一个程序源文件之后，编译得到的二进制可执行文件存放在电脑的硬盘上，此时它是一个静态的文件，一般称之为程序。</p><p>当这个程序被启动的时候，操作系统将会做下面几件事情：</p><blockquote><ol><li>把程序的内容 (代码段、数据段) 从硬盘复制到内存中；</li><li>创建一个数据结构 PCB (进程控制块)，来描述这个程序的各种信息 (例如：使用的资源，打开的文件描述符...);</li><li>在代码段中定位到入口函数的地址，让 CPU 从这个地址开始执行。</li></ol></blockquote><p><img data-src="https://img2020.cnblogs.com/news/1440498/202101/1440498-20210117125101905-2038618662.png" alt=""></p><p>当程序开始被执行时，就变成一个动态的状态，一般称之为进程。</p><blockquote><p>内存分为：物理内存和虚拟内存。操作系统对物理内存进行管理、包装，我们开发者面对的是操作系统提供的虚拟内存。<br>这 2 个概念不妨碍文章的理解，因此就统一称之为内存。</p></blockquote><p>在我们的程序中，通过一个变量名来定义变量、使用变量。变量本身是一个确确实实存在的东西，变量名是一个抽象的概念，用来代表这个变量。就比如：我是一个实实在在的人，是客观存在与这个地球上的，道哥是我给自己起的一个名字，这个名字是任意取得，只要自己觉得好听就行，如果我愿意还可以起名叫：鸟哥、龙哥等等。</p><p>那么，我们定义一个变量之后，这个变量放在哪里呢？那就是内存的数据区。内存是一个很大的存储区域，被操作系统划分为一个一个的小空间，操作系统通过地址来管理内存。</p><p><img data-src="https://img2020.cnblogs.com/blog/1440498/202101/1440498-20210117125102111-1868332977.png" alt=""></p><p>内存中的最小存储单位是字节 (8 个 bit)，一个内存的完整空间就是由这一个一个的字节连续组成的。在上图中，每一个小格子代表一个字节，但是好像大家在书籍中没有这么来画内存模型的，更常见的是下面这样的画法：</p><p><img data-src="https://img2020.cnblogs.com/blog/1440498/202101/1440498-20210117125102296-905586996.png" alt=""></p><p>也就是把连续的 4 个字节的空间画在一起，这样就便于表述和理解，特别是深入到代码对齐相关知识时更容易理解。(我认为根本原因应该是：大家都这么画，已经看顺眼了～～)</p><h2 id="2-32位与64位系统"><a class="anchor" href="#2-32位与64位系统">#</a> 2. 32 位与 64 位系统</h2><p>我们平时所说的计算机是 32 位、64 位，指的是计算机的 CPU 中寄存器的最大存储长度，如果寄存器中最大存储 32bit 的数据，就称之为 32 位系统。</p><p>在计算机中，数据一般都是在硬盘、内存和寄存器之间进行来回存取。CPU 通过 3 种总线把各组成部分联系在一起：地址总线、数据总线和控制总线。地址总线的宽度决定了 CPU 的寻址能力，也就是 CPU 能达到的最大地址范围。</p><p><img data-src="https://img2020.cnblogs.com/news/1440498/202101/1440498-20210117125102509-2034987460.png" alt=""></p><p>刚才说了，内存是通过地址来管理的，那么 CPU 想从内存中的某个地址空间上存取一个数据，那么 CPU 就需要在地址总线上输出这个存储单元的地址。假如地址总线的宽度是 8 位，能表示的最大地址空间就是 256 个字节，能找到内存中最大的存储单元是 255 这个格子 (从 0 开始)。即使内存条的实际空间是 2G 字节，CPU 也没法使用后面的内存地址空间。如果地址总线的宽度是 32 位，那么能表示的最大地址就是 2 的 32 次方，也就是 4G 字节的空间。</p><p><em>【注意】</em>：这里只是描述地址总线的概念，实际的计算机中地址计算方式要复杂的多，比如：虚拟内存中采用分段、分页、偏移量来定位实际的物理内存，在分页中还有大页、小页之分，感兴趣的同学可以自己查一下相关资料。</p><h2 id="3-变量"><a class="anchor" href="#3-变量">#</a> 3. 变量</h2><p>我们在 C 程序中使用变量来 “代表” 一个数据，使用函数名来 “代表” 一个函数，变量名和函数名是程序员使用的助记符。变量和函数最终是要放到内存中才能被 CPU 使用的，而内存中所有的信息 (代码和数据) 都是以二进制的形式来存储的，计算机根据就不会从格式上来区分哪些是代码、哪些是数据。CPU 在访问内存的时候需要的是地址，而不是变量名、函数名。</p><p><strong>问题来了</strong>：在程序代码中使用变量名来指代变量，而变量在内存中是根据地址来存放的，这二者之间如何映射 (关联) 起来的？</p><p>答案是：编译器！编译器在编译文本格式的 C 程序文件时，会根据目标运行平台 (就是编译出的二进制程序运行在哪里？是 x86 平台的电脑？还是 ARM 平台的开发板？) 来安排程序中的各种地址，例如：加载到内存中的地址、代码段的入口地址等等，同时编译器也会把程序中的所有变量名，转成该变量在内存中的存储地址。</p><p>变量有 2 个重要属性：变量的类型和变量的值。</p><p>示例：代码中定义了一个变量</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>类型是 int 型，值是 20。这个变量在内存中的存储模型为：</p><p><img data-src="https://img2020.cnblogs.com/blog/1440498/202101/1440498-20210117125102684-560300929.png" alt=""></p><p>我们在代码中使用变量名 a，在程序执行的时候就表示使用 0x11223344 地址所对应的那个存储单元中的数据。因此，可以理解为变量名 a 就等价于这个地址 0x11223344。换句话说，如果我们可以提前知道编译器把变量 a 安排在地址 0x11223344 这个单元格中，我们就可以在程序中直接用这个地址值来操作这个变量。</p><p>在上图中，变量 a 的值为 20，在内存中占据了 4 个格子的空间，也就是 4 个字节。为什么是 4 个字节呢？在 C 标准中并没有规定每种数据类型的变量一定要占用几个字节，这是与具体的机器、编译器有关。</p><p>比如：32 位的编译器中：</p><blockquote><p>char: 1 个字节；<br>short int: 2 个字节；<br>int: 4 个字节；<br>long: 4 个字节。</p></blockquote><p>比如：64 位的编译器中：</p><blockquote><p>char: 1 个字节；<br>short int: 2 个字节；<br>int: 4 个字节；<br>long: 8 个字节。</p></blockquote><p>为了方便描述，下面都以 32 位为例，也就是 int 型变量在内存中占据 4 个字节。</p><p>另外，0x11223344，0x11223345，0x11223346，0x11223347 这连续的、从低地址到高地址的 4 个字节用来存储变量 a 的数值 20。在图示中，使用十六进制来表示，十进制数值 20 转成 16 进制就是：0x00000014，所以从开始地址依次存放 0x00、0x00、0x00、0x14 这 4 个字节 (存储顺序涉及到大小端的问题，不影响文本理解)。</p><p>根据这个图示，如果在程序中想知道变量 a 存储在内存中的什么位置，可以使用取地址操作符 &amp;，如下：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"&amp;a = 0x%x \n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这句话将会打印出： <code>&amp;a = 0x11223344</code> 。</p><p>考虑一下，在 32 位系统中：指针变量占用几个字节？</p><h2 id="4-指针变量"><a class="anchor" href="#4-指针变量">#</a> 4. 指针变量</h2><p>指针变量可以分 2 个层次来理解：</p><blockquote><ol><li>指针变量首先是一个变量，所以它拥有变量的所有属性：类型和值。它的类型就是指针，它的值是其他变量的地址。 既然是一个变量，那么在内存中就需要为这个变量分配一个存储空间。在这个存储空间中，存放着其他变量的地址。</li><li>指针变量所指向的数据类型，这是在定义指针变量的时候就确定的。例如：int *p; 意味着指针指向的是一个 int 型的数据。</li></ol></blockquote><p>首先回答一下刚才那个问题，在 32 位系统中，一个指针变量在内存中占据 4 个字节的空间。因为 CPU 对内存空间寻址时，使用的是 32 位地址空间 (4 个字节)，也就是用 4 个字节就能存储一个内存单元的地址。而指针变量中的值存储的就是地址，所以需要 4 个字节的空间来存储一个指针变量的值。</p><p>示例：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>pa<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>pa <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"value = %d \n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>pa<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在内存中的存储模型如下：</p><p><img data-src="https://img2020.cnblogs.com/blog/1440498/202101/1440498-20210117125102911-482698012.png" alt=""></p><p>对于指针变量 pa 来说，首先它是一个变量，因此在内存中需要有一个空间来存储这个变量，这个空间的地址就是 0x11223348；</p><p>其次，这个内存空间中存储的内容是变量 a 的地址，而 a 的地址为 0x11223344，所以指针变量 pa 的地址空间中，就存储了 0x11223344 这个值。</p><p>这里对两个操作符 &amp; 和 * 进行说明：</p><blockquote><p>&amp;：取地址操作符，用来获取一个变量的地址。上面代码中 &amp; a 就是用来获取变量 a 在内存中的存储地址，也就是 0x11223344。<br>*：这个操作符用在 2 个场景中：定义一个指针的时候，获取一个指针所指向的变量值的时候。</p><blockquote><ol><li>int _pa; 这个语句中的_表示定义的变量 pa 是一个指针，前面的 int 表示 pa 这个指针指向的是一个 int 类型的变量。不过此时我们没有给 pa 进行赋值，也就是说此刻 pa 对应的存储单元中的 4 个字节里的值是没有初始化的，可能是 0x00000000，也可能是其他任意的数字，不确定；</li><li>printf 语句中的 * 表示获取 pa 指向的那个 int 类型变量的值，学名叫解引用，我们只要记住是获取指向的变量的值就可以了。</li></ol></blockquote></blockquote><h2 id="5-操作指针变量"><a class="anchor" href="#5-操作指针变量">#</a> 5. 操作指针变量</h2><p>对指针变量的操作包括 3 个方面：</p><blockquote><ol><li>操作指针变量自身的值；</li><li>获取指针变量所指向的数据；</li><li>以什么样数据类型来使用 / 解释指针变量所指向的内容。</li></ol></blockquote><h3 id="51-指针变量自身的值"><a class="anchor" href="#51-指针变量自身的值">#</a> 5.1 指针变量自身的值</h3><p><code>int a = 20;</code> 这个语句是定义变量 a，在随后的代码中，只要写下 a 就表示要操作变量 a 中存储的值，操作有两种：读和写。</p><blockquote><p><code>printf(&quot;a = %d \n&quot;, a);</code>  这个语句就是要读取变量 a 中的值，当然是 20；<br><code>a = 100;</code> 这个语句就是要把一个数值 100 写入到变量 a 中。</p></blockquote><p>同样的道理， <code>int *pa;</code> 语句是用来定义指针变量 pa，在随后的代码中，只要写下 pa 就表示要操作变量 pa 中的值：</p><blockquote><p><code>printf(&quot;pa = %d \n&quot;, pa);</code>  这个语句就是要读取指针变量 pa 中的值，当然是 0x11223344；<br><code>pa = &amp;a;</code> 这个语句就是要把新的值写入到指针变量 pa 中。再次强调一下，指针变量中存储的是地址，如果我们可以提前知道变量 a 的地址是 0x11223344，那么我们也可以这样来赋值:pa = 0x11223344;</p></blockquote><p>思考一下，<em>如果执行这个语句 <code>printf(&quot;&amp;pa =0x%x \n&quot;, &amp;pa);</code> ，打印结果会是什么？</em></p><p>上面已经说过，操作符 &amp; 是用来取地址的，那么 &amp; pa 就表示获取指针变量 pa 的地址，上面的内存模型中显示指针变量 pa 是存储在 0x11223348 这个地址中的，因此打印结果就是： <code>&amp;pa = 0x11223348</code> 。</p><h3 id="52-获取指针变量所指向的数据"><a class="anchor" href="#52-获取指针变量所指向的数据">#</a> 5.2 获取指针变量所指向的数据</h3><p>指针变量所指向的数据类型是在定义的时候就明确的，也就是说指针 pa 指向的数据类型就是 int 型，因此在执行 <code>printf(&quot;value = %d \n&quot;, *pa);</code> 语句时，首先知道 pa 是一个指针，其中存储了一个地址 (0x11223344)，然后通过操作符 * 来获取这个地址 (0x11223344) 对应的那个存储空间中的值；又因为在定义 pa 时，已经指定了它指向的值是一个 int 型，所以我们就知道了地址 0x11223344 中存储的就是一个 int 类型的数据。</p><h3 id="53-以什么样的数据类型来使用解释指针变量所指向的内容"><a class="anchor" href="#53-以什么样的数据类型来使用解释指针变量所指向的内容">#</a> 5.3 以什么样的数据类型来使用 / 解释指针变量所指向的内容</h3><p>如下代码：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">30000</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>pa <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"value = %d \n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>pa<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>根据以上的描述，我们知道 printf 的打印结果会是 <code>value = 30000</code> ，十进制的 30000 转成十六进制是 0x00007530，内存模型如下：</p><p><img data-src="https://img2020.cnblogs.com/news/1440498/202101/1440498-20210117125103217-894196313.png" alt=""></p><p>现在我们做这样一个测试：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">char</span> <span class="token operator">*</span>pc <span class="token operator">=</span> <span class="token number">0x11223344</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"value = %d \n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>pc<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>指针变量 pc 在定义的时候指明：它指向的数据类型是 char 型，pc 变量中存储的地址是 0x11223344。当使用 * pc 获取指向的数据时，将会按照 char 型格式来读取 0x11223344 地址处的数据，因此将会打印 <code>value = 0</code> (在计算机中，ASCII 码是用等价的数字来存储的)。</p><p>这个例子中说明了一个重要的概念：在内存中一切都是数字，如何来操作 (解释) 一个内存地址中的数据，完全是由我们的代码来告诉编译器的。刚才这个例子中，虽然 0x11223344 这个地址开始的 4 个字节的空间中，存储的是整型变量 a 的值，但是我们让 pc 指针按照 char 型数据来使用 / 解释这个地址处的内容，这是完全合法的。</p><p>以上内容，就是指针最根本的心法了。把这个心法整明白了，剩下的就是多见识、多练习的问题了。</p><h1 id="三-指针的几个相关概念"><a class="anchor" href="#三-指针的几个相关概念">#</a> 三、指针的几个相关概念</h1><h2 id="1-const属性"><a class="anchor" href="#1-const属性">#</a> 1. const 属性</h2><p>const 标识符用来表示一个对象的不可变的性质，例如定义：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>在后面的代码中就不能改变变量 b 的值了，b 中的值永远是 20。同样的，如果用 const 来修饰一个指针变量：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span></pre></td></tr></table></figure><p>内存模型如下：</p><p><img data-src="https://img2020.cnblogs.com/blog/1440498/202101/1440498-20210117125103388-1710480496.png" alt=""></p><p>这里的 const 用来修饰指针变量 p，根据 const 的性质可以得出结论：p 在定义为变量 a 的地址之后，就固定了，不能再被改变了，也就是说指针变量 pa 中就只能存储变量 a 的地址 0x11223344。如果在后面的代码中写 <code>p = &amp;b;</code> ，编译时就会报错，因为 p 是不可改变的，不能再被设置为变量 b 的地址。</p><p>但是，指针变量 p 所指向的那个变量 a 的值是可以改变的，即： <code>*p = 21;</code> 这个语句是合法的，因为指针 p 的值没有改变 (仍然是变量 c 的地址 0x11223344)，改变的是变量 c 中存储的值。</p><p>与下面的代码区分一下：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>p <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span></pre></td></tr></table></figure><p>这里的 const 没有放在 p 的旁边，而是放在了类型 int 的旁边，这就说明 const 符号不是用来修饰 p 的，而是用来修饰 p 所指向的那个变量的。所以，如果我们写 <code>p = &amp;b;</code> 把变量 b 的地址赋值给指针 p，就是合法的，因为 p 的值可以被改变。</p><p>但是这个语句 <code>*p = 21</code> 就是非法了，因为定义语句中的 const 就限制了通过指针 p 获取的数据，不能被改变，只能被用来读取。这个性质常常被用在函数参数上，例如下面的代码，用来计算一块数据的 CRC 校验，这个函数只需要读取原始数据，不需要 (也不可以) 改变原始数据，因此就需要在形参指针上使用 const 修饰符：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">short</span> <span class="token keyword">int</span> <span class="token function">getDataCRC</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pData<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">short</span> <span class="token keyword">int</span> crc <span class="token operator">=</span> <span class="token number">0x0000</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 计算 CRC</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">return</span> crc<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="2-void型指针"><a class="anchor" href="#2-void型指针">#</a> 2. void 型指针</h2><p>关键字 void 并不是一个真正的数据类型，它体现的是一种抽象，指明不是任何一种类型，一般有 2 种使用场景：</p><blockquote><ol><li>函数的返回值和形参；</li><li>定义指针时不明确规定所指数据的类型，也就意味着可以指向任意类型。</li></ol></blockquote><p>指针变量也是一种变量，变量之间可以相互赋值，那么指针变量之间也可以相互赋值，例如：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span></pre></td></tr></table></figure><p>变量 a 赋值给变量 b，指针 p1 赋值给指针 p2，注意到它们的类型必须是相同的：a 和 b 都是 int 型，p1 和 p2 都是指向 int 型，所以可以相互赋值。那么如果数据类型不同呢？必须进行强制类型转换。例如：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">char</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>p1<span class="token punctuation">;</span></pre></td></tr></table></figure><p>内存模型如下：</p><p><img data-src="https://img2020.cnblogs.com/blog/1440498/202101/1440498-20210117125103690-530190610.png" alt=""></p><p>p1 指针指向的是 int 型数据，现在想把它的值 (0x11223344) 赋值给 p2，但是由于在定义 p2 指针时规定它指向的数据类型是 char 型，因此需要把指针 p1 进行强制类型转换，也就是把地址 0x11223344 处的数据按照 char 型数据来看待，然后才可以赋值给 p2 指针。</p><p>如果我们使用 <code>void *p2</code> 来定义 p2 指针，那么在赋值时就不需要进行强制类型转换了，例如：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span></pre></td></tr></table></figure><p>指针 p2 是 void<em> 型，意味着可以把任意类型的指针赋值给 p2，但是不能反过来操作，也就是不能把 void</em> 型指针直接赋值给其他确定类型的指针，而必须要强制转换成被赋值指针所指向的数据类型，如下代码，必须把 p2 指针强制转换成 int * 型之后，再赋值给 p3 指针：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">void</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>p3 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>p2<span class="token punctuation">;</span></pre></td></tr></table></figure><p>我们来看一个系统函数：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> dest<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> src<span class="token punctuation">,</span> size_t len<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>第一个参数类型是 void*，这正体现了系统对内存操作的真正意义：它并不关心用户传来的指针具体指向什么数据类型，只是把数据挨个存储到这个地址对应的空间中。</p><p>第二个参数同样如此，此外还添加了 const 修饰符，这样就说明了 memcpy 函数只会从 src 指针处读取数据，而不会修改数据。</p><h2 id="3-空指针和野指针"><a class="anchor" href="#3-空指针和野指针">#</a> 3. 空指针和野指针</h2><p>一个指针必须指向一个有意义的地址之后，才可以对指针进行操作。如果指针中存储的地址值是一个随机值，或者是一个已经失效的值，此时操作指针就非常危险了，一般把这样的指针称作野指针，C 代码中很多指针相关的 bug 就来源于此。</p><h3 id="31-空指针不指向任何东西的指针"><a class="anchor" href="#31-空指针不指向任何东西的指针">#</a> 3.1 空指针：不指向任何东西的指针</h3><p>在定义一个指针变量之后，如果没有赋值，那么这个指针变量中存储的就是一个随机值，有可能指向内存中的任何一个地址空间，此时万万不可以对这个指针进行写操作，因为它有可能指向内存中的代码段区域、也可能指向内存中操作系统所在的区域。</p><p>一般会将一个指针变量赋值为 NULL 来表示一个空指针，而 C 语言中，NULL 实质是 ((void*) 0) ， 在 C++ 中，NULL 实质是 0。在标准库头文件 stdlib.h 中，有如下定义：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__cplusplus</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre>     <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span>    <span class="token expression"><span class="token number">0</span></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span>    </span></pre></td></tr><tr><td data-num="4"></td><td><pre>     <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">NULL</span>    <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span></span></span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></pre></td></tr></table></figure><h3 id="32-野指针地址已经失效的指针"><a class="anchor" href="#32-野指针地址已经失效的指针">#</a> 3.2 野指针：地址已经失效的指针</h3><p>我们都知道，函数中的局部变量存储在栈区，通过 malloc 申请的内存空间位于堆区，如下代码：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>内存模型为：</p><p><img data-src="https://img2020.cnblogs.com/news/1440498/202101/1440498-20210117125104055-1314083095.png" alt=""></p><p>在堆区申请了 4 个字节的空间，然后强制类型转换为 int<em> 型之后，赋值给指针变量 p，然后通过</em> p 设置这个地址中的值为 14，这是合法的。如果在释放了 p 指针指向的空间之后，再使用 * p 来操作这段地址，那就是非常危险了，因为这个地址空间可能已经被操作系统分配给其他代码使用，如果对这个地址里的数据强行操作，程序立刻崩溃的话，将会是我们最大的幸运！</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 在 free 之后就不可以再操作 p 指针中的数据了。</span></pre></td></tr><tr><td data-num="5"></td><td><pre>p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment">// 最好加上这一句。</span></pre></td></tr></table></figure><h1 id="四-指向不同数据类型的指针"><a class="anchor" href="#四-指向不同数据类型的指针">#</a> 四、指向不同数据类型的指针</h1><h2 id="1-数值型指针"><a class="anchor" href="#1-数值型指针">#</a> 1. 数值型指针</h2><p>通过上面的介绍，指向数值型变量的指针已经很明白了，需要注意的就是指针所指向的数据类型。</p><h2 id="2-字符串指针"><a class="anchor" href="#2-字符串指针">#</a> 2. 字符串指针</h2><p>字符串在内存中的表示有 2 种：</p><blockquote><ol><li>用一个数组来表示，例如：char name1 [8] = &quot;zhangsan&quot;;</li><li>用一个 char * 指针来表示，例如：char *name2 = &quot;zhangsan&quot;;</li></ol></blockquote><p>name1 在内存中占据 8 个字节，其中存储了 8 个字符的 ASCII 码值；name2 在内存中占据 9 个字节，因为除了存储 8 个字符的 ASCII 码值，在最后一个字符 'n' 的后面还额外存储了一个 '\0'，用来标识字符串结束。</p><p>对于字符串来说，使用指针来操作是非常方便的，例如：变量字符串 name2:</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">char</span> <span class="token operator">*</span>name2 <span class="token operator">=</span> <span class="token string">"zhangsan"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> name2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>p <span class="token operator">!=</span> <span class="token char">'\0'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    p <span class="token operator">=</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>在 while 的判断条件中，检查 p 指针指向的字符是否为结束符 '\0'。在循环体重，打印出当前指向的字符之后，对指针比那里进行自增操作，因为指针 p 所指向的数据类型是 char，每个 char 在内存中占据一个字节，因此指针 p 在自增 1 之后，就指向下一个存储空间。</p><p><img data-src="https://img2020.cnblogs.com/blog/1440498/202101/1440498-20210117125104301-302814499.png" alt=""></p><p>也可以把循环体中的 2 条语句写成 1 条语句：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>假如一个指针指向的数据类型为 int 型，那么执行 <code>p = p + 1;</code> 之后，指针 p 中存储的地址值将会增加 4，因为一个 int 型数据在内存中占据 4 个字节的空间，如下所示：</p><p><img data-src="https://img2020.cnblogs.com/blog/1440498/202101/1440498-20210117125104501-691967061.png" alt=""></p><p>思考一个问题：void * 型指针能够递增吗？如下测试代码：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token operator">*</span>p <span class="token operator">=</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"1: p = 0x%x \n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>p <span class="token operator">=</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"2: p = 0x%x \n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>打印结果如下：</p><figure class="highlight makefile"><figcaption data-lang="makefile"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token target symbol">1</span><span class="token punctuation">:</span> p <span class="token operator">=</span> 0x733748c0 </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token target symbol">2</span><span class="token punctuation">:</span> p <span class="token operator">=</span> 0x733748c1</pre></td></tr></table></figure><p>说明 void * 型指针在自增时，是按照一个字节的跨度来计算的。</p><h2 id="3-指针数组与数组指针"><a class="anchor" href="#3-指针数组与数组指针">#</a> 3. 指针数组与数组指针</h2><p>这 2 个说法经常会混淆，至少我是如此，先看下这 2 条语句：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>p1<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 指针数组</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 数组指针</span></pre></td></tr></table></figure><h3 id="31-指针数组"><a class="anchor" href="#31-指针数组">#</a> 3.1 指针数组</h3><p>第 1 条语句中：中括号 [] 的优先级高，因此与 p1 先结合，表示一个数组，这个数组中有 3 个元素，这 3 个元素都是指针，它们指向的是 int 型数据。可以这样来理解：如果有这个定义 <code>char p[3]</code> ，很容易理解这是一个有 3 个 char 型元素的数组，那么把 char 换成 int*，意味着数组里的元素类型是 int * 型 (指向 int 型数据的指针)。内存模型如下 (注意：三个指针指向的地址并不一定是连续的)：</p><p><img data-src="https://img2020.cnblogs.com/news/1440498/202101/1440498-20210117125104725-172910538.png" alt=""></p><p>如果向指针数组中的元素赋值，需要逐个把变量的地址赋值给指针元素：</p><figure class="highlight xml"><figcaption data-lang="XML"></figcaption><table><tr><td data-num="1"></td><td><pre>int a = 1, b = 2, c = 3;</pre></td></tr><tr><td data-num="2"></td><td><pre>char *p1[3];</pre></td></tr><tr><td data-num="3"></td><td><pre>p1[0] = <span class="token entity named-entity" title="&a;">&amp;a;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>p1[1] = <span class="token entity named-entity" title="&b;">&amp;b;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>p1[2] = <span class="token entity named-entity" title="&c;">&amp;c;</span></pre></td></tr></table></figure><h3 id="32-数组指针"><a class="anchor" href="#32-数组指针">#</a> 3.2 数组指针</h3><p>第 2 条语句中：小括号让 p2 与<em>结合，表示 p2 是一个指针，这个指针指向了一个数组，数组中有 3 个元素，每一个元素的类型是 int 型。可以这样来理解：如果有这个定义 <code>int p[3]</code> ，很容易理解这是一个有 3 个 char 型元素的数组，那么把数组名 p 换成是</em> p2，也就是 p2 是一个指针，指向了这个数组。内存模型如下 (注意：指针指向的地址是一个数组，其中的 3 个元素是连续放在内存中的)：</p><p><img data-src="https://img2020.cnblogs.com/blog/1440498/202101/1440498-20210117125105041-1650837342.png" alt=""></p><p>在前面我们说到取地址操作符 &amp;，用来获得一个变量的地址。凡事都有特殊情况，对于获取地址来说，下面几种情况不需要使用 &amp; 操作符：</p><blockquote><ol><li>字符串字面量作为右值时，就代表这个字符串在内存中的首地址；</li><li>数组名就代表这个数组的地址，也等于这个数组的第一个元素的地址；</li><li>函数名就代表这个函数的地址。</li></ol></blockquote><p>因此，对于一下代码，三个 printf 语句的打印结果是相同的：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"0x%x \n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"0x%x \n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"0x%x \n"</span><span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>思考一下，如果对这里的 p2 指针执行 <code>p2 = p2 + 1;</code> 操作，p2 中的值将会增加多少？</p><p>答案是 12 个字节。因为 p2 指向的是一个数组，这个数组中包含 3 个元素，每个元素占据 4 个字节，那么这个数组在内存中一共占据 12 个字节，因此 p2 在加 1 之后，就跳过 12 个字节。</p><p><img data-src="https://img2020.cnblogs.com/blog/1440498/202101/1440498-20210117125105217-1534229283.png" alt=""></p><h2 id="4-二维数组和指针"><a class="anchor" href="#4-二维数组和指针">#</a> 4. 二维数组和指针</h2><p>一维数组在内存中是连续分布的多个内存单元组成的，而二维数组在内存中也是连续分布的多个内存单元组成的，从内存角度来看，一维数组和二维数组没有本质差别。</p><p>和一维数组类似，二维数组的数组名表示二维数组的第一维数组中首元素的首地址，用代码来说明：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>swig￼<span class="token number">0</span><span class="token operator">--</span><span class="token operator">></span><span class="token punctuation">;</span> <span class="token comment">// 二维数组</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p0<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>   <span class="token comment">//p0 是一个指针，指向一个数组</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p1<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>   <span class="token comment">//p1 是一个指针，指向一个数组</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>   <span class="token comment">//p2 是一个指针，指向一个数组</span></pre></td></tr><tr><td data-num="5"></td><td><pre>p0 <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>p1 <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>p2 <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"0: %d %d %d \n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>p0 <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>p0 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>p0 <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"1: %d %d %d \n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>p1 <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>p1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>p1 <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"2: %d %d %d \n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>p2 <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>p2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>p2 <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>打印结果是：</p><figure class="highlight makefile"><figcaption data-lang="makefile"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token target symbol">0</span><span class="token punctuation">:</span> 1 2 3 </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token target symbol">1</span><span class="token punctuation">:</span> 4 5 6 </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token target symbol">2</span><span class="token punctuation">:</span> 7 8 9</pre></td></tr></table></figure><p>我们拿第一个 printf 语句来分析：p0 是一个指针，指向一个数组，数组中包含 3 个元素，每个元素在内存中占据 4 个字节。现在我们想获取这个数组中的数据，如果直接对 p0 执行加 1 操作，那么 p0 将会跨过 12 个字节 (就等于 p1 中的值了)，因此需要使用解引用操作符 *，把 p0 转为指向 int 型的指针，然后再执行加 1 操作，就可以得到数组中的 int 型数据了。</p><h2 id="5-结构体指针"><a class="anchor" href="#5-结构体指针">#</a> 5. 结构体指针</h2><p>C 语言中的基本数据类型是预定义的，结构体是用户定义的，在指针的使用上可以进行类比，唯一有区别的就是在结构体指针中，需要使用 <code>-&gt;</code> 箭头操作符来获取结构体中的成员变量，例如：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span> </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> age<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span> Student<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>Student s<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>s<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token function">strcpy</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">"lisi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>Student <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"age = %d, name = %s \n"</span><span class="token punctuation">,</span> p<span class="token operator">-></span>age<span class="token punctuation">,</span> p<span class="token operator">-></span>name<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>看起来似乎没有什么技术含量，如果是结构体数组呢？ 例如：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>Student s<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>Student <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>s<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"size of Student = %d \n"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Student<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"1: 0x%x, 0x%x \n"</span><span class="token punctuation">,</span> s<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>p<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"2: 0x%x \n"</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>打印结果是：</p><figure class="highlight txt"><figcaption data-lang="txt"></figcaption><table><tr><td data-num="1"></td><td><pre>size of Student = 12 </pre></td></tr><tr><td data-num="2"></td><td><pre>1: 0x4c02ac00, 0x4c02ac00 </pre></td></tr><tr><td data-num="3"></td><td><pre>2: 0x4c02ac0c</pre></td></tr></table></figure><p>在执行 <code>p++</code> 操作后，p 需要跨过的空间是一个结构体变量在内存中占据的大小 (12 个字节)，所以此时 p 就指向了数组中第 2 个元素的首地址，内存模型如下：</p><p><img data-src="https://img2020.cnblogs.com/news/1440498/202101/1440498-20210117125105441-408121878.png" alt=""></p><h2 id="6-函数指针"><a class="anchor" href="#6-函数指针">#</a> 6. 函数指针</h2><p>每一个函数在经过编译之后，都变成一个包含多条指令的集合，在程序被加载到内存之后，这个指令集合被放在代码区，我们在程序中使用函数名就代表了这个指令集合的开始地址。</p><p><img data-src="https://img2020.cnblogs.com/blog/1440498/202101/1440498-20210117125105598-2023229576.png" alt=""></p><p>函数指针，本质上仍然是一个指针，只不过这个指针变量中存储的是一个函数的地址。函数最重要特性是什么？可以被调用！因此，当定义了一个函数指针并把一个函数地址赋值给这个指针时，就可以通过这个函数指针来调用函数。</p><p>如下示例代码：</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token keyword">add</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> x<span class="token punctuation">,</span><span class="token class-name"><span class="token keyword">int</span></span> y<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">return</span> x<span class="token operator">+</span>y<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token class-name"><span class="token keyword">int</span></span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    p <span class="token operator">=</span> <span class="token keyword">add</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d + %d = %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token function">p</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>前文已经说过，函数的名字就代表函数的地址，所以函数名 add 就代表了这个加法函数在内存中的地址。<br><code>int (*p)(int, int);</code> 这条语句就是用来定义一个函数指针，它指向一个函数，这个函数必须符合下面这 2 点 (学名叫：函数签名)：</p><blockquote><ol><li>有 2 个 int 型的参数；</li><li>有一个 int 型的返回值。</li></ol></blockquote><p>代码中的 add 函数正好满足这个要求，因此，可以把 add 赋值给函数指针 p，此时 p 就指向了内存中这个函数存储的地址，后面就可以用函数指针 p 来调用这个函数了。</p><p>在示例代码中，函数指针 p 是直接定义的，那如果想定义 2 个函数指针，难道需要像下面这样定义吗？</p><figure class="highlight csharp"><figcaption data-lang="C#"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这里的参数比较简单，如果函数很复杂，这样的定义方式岂不是要烦死？可以用 typedef 关键字来定义一个函数指针类型：</p><figure class="highlight cpp"><figcaption data-lang="C++"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>pFunc<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>然后用这样的方式 <code>pFunc p1, p2;</code> 来定义多个函数指针就方便多了。注意：只能把与函数指针类型具有相同签名的函数赋值给 p1 和 p2，也就是参数的个数、类型要相同，返回值也要相同。</p><p>注意：这里有几个小细节稍微了解一下：</p><blockquote><ol><li>在赋值函数指针时，使用 p = &amp;a; 也是可以的；</li><li>使用函数指针调用时，使用 (*p)(a, b); 也是可以的。</li></ol></blockquote><p>这里没有什么特殊的原理需要讲解，最终都是编译器帮我们处理了这里的细节，直接记住即可。</p><p>函数指针整明白之后，再和数组结合在一起：函数指针数组。示例代码如下：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token function">mul</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> <span class="token function">divide</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> a <span class="token operator">/</span> b<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> add<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> sub<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> mul<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    p<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> divide<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d + %d = %d \n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d - %d = %d \n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d * %d = %d \n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d / %d = %d \n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这条语句不太好理解: <code>int (*p[4])(int, int);</code> ，先分析中间部分，标识符 p 与中括号 [] 结合 (优先级高)，所以 p 是一个数组，数组中有 4 个元素；然后剩下的内容表示一个函数指针，那么就说明数组中的元素类型是函数指针，也就是其他函数的地址，内存模型如下：</p><p><img data-src="https://img2020.cnblogs.com/blog/1440498/202101/1440498-20210117125105837-1522976845.png" alt=""></p><p>如果还是难以理解，那就回到指针的本质概念上：指针就是一个地址！这个地址中存储的内容是什么根本不重要，重要的是你告诉计算机这个内容是什么。如果你告诉它：这个地址里存放的内容是一个函数，那么计算机就去调用这个函数。那么你是如何告诉计算机的呢，就是在定义指针变量的时候，仅此而已！</p><h1 id="五-总结"><a class="anchor" href="#五-总结">#</a> 五、总结</h1><p>我已经把自己知道的所有指针相关的概念、语法、使用场景都作了讲解，就像一个小酒馆的掌柜，把自己的美酒佳肴都呈现给你，但愿你已经酒足饭饱！</p><p>如果以上的内容太多，一时无法消化，那么下面的这两句话就作为饭后甜点为您奉上，在以后的编程中，如果遇到指针相关的困惑，就想一想这两句话，也许能让你茅塞顿开。</p><blockquote><ol><li>指针就是地址，地址就是指针。</li><li>指针就是指向内存中的一块空间，至于如何来解释 / 操作这块空间，由这个指针的类型来决定。</li></ol></blockquote><p>另外还有一点嘱咐，那就是学习任何一门编程语言，一定要弄清楚内存模型，内存模型，内存模型！</p><p>祝您好运！</p><hr><p>【原创声明】</p><blockquote><p>作者：道哥 (公众号: IOT 物联网小镇)<br>知乎：道哥<br>B 站：道哥分享<br>掘金：道哥分享<br>CSDN：道哥分享</p></blockquote><p>如果觉得文章不错，请转发、分享给您的朋友。</p><p>我会把十多年嵌入式开发中的项目实战经验进行总结、分享，相信不会让你失望的！</p><p>长按下图二维码关注，每篇文章都有干货。</p><p><img data-src="https://img2020.cnblogs.com/news/1440498/202101/1440498-20210117125106052-2002121297.jpg" alt=""></p><p>转载：欢迎转载，但未经作者同意，必须保留此段声明，必须在文章中给出原文连接。</p><div class="tags"><a href="/tags/reshipment/" rel="tag"><i class="ic i-tag"></i> reshipment</a> <a href="/tags/pointer/" rel="tag"><i class="ic i-tag"></i> pointer</a> <a href="/tags/clanguage/" rel="tag"><i class="ic i-tag"></i> clanguage</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-08-16 00:05:44" itemprop="dateModified" datetime="2023-08-16T00:05:44+08:00">2023-08-16</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Percy Everard <i class="ic i-at"><em>@</em></i>fengyepiaosa</li><li class="link"><strong>本文链接：</strong> <a href="https://percyeverard.github.io/2023/08/15/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/" title="C 语言指针详解">https://percyeverard.github.io/2023/08/15/C语言指针详解/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/08/15/x86%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E9%9B%86%E6%B1%87%E6%80%BB/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;08&#x2F;09&#x2F;yY9JrKwM3DU7mc8.jpg" title="x86汇编指令集汇总"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 编程拓展</span><h3>x86汇编指令集汇总</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">一、前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-%E5%8F%98%E9%87%8F%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">2.</span> <span class="toc-text">二、变量与指针的本质</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80"><span class="toc-number">2.1.</span> <span class="toc-text">1. 内存地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-32%E4%BD%8D%E4%B8%8E64%E4%BD%8D%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.2.</span> <span class="toc-text">2. 32 位与 64 位系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8F%98%E9%87%8F"><span class="toc-number">2.3.</span> <span class="toc-text">3. 变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="toc-number">2.4.</span> <span class="toc-text">4. 指针变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%93%8D%E4%BD%9C%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="toc-number">2.5.</span> <span class="toc-text">5. 操作指针变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#51-%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E8%87%AA%E8%BA%AB%E7%9A%84%E5%80%BC"><span class="toc-number">2.5.1.</span> <span class="toc-text">5.1 指针变量自身的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52-%E8%8E%B7%E5%8F%96%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E6%89%80%E6%8C%87%E5%90%91%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">2.5.2.</span> <span class="toc-text">5.2 获取指针变量所指向的数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-%E4%BB%A5%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9D%A5%E4%BD%BF%E7%94%A8%E8%A7%A3%E9%87%8A%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E6%89%80%E6%8C%87%E5%90%91%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">2.5.3.</span> <span class="toc-text">5.3 以什么样的数据类型来使用 &#x2F; 解释指针变量所指向的内容</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-%E6%8C%87%E9%92%88%E7%9A%84%E5%87%A0%E4%B8%AA%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">3.</span> <span class="toc-text">三、指针的几个相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-const%E5%B1%9E%E6%80%A7"><span class="toc-number">3.1.</span> <span class="toc-text">1. const 属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-void%E5%9E%8B%E6%8C%87%E9%92%88"><span class="toc-number">3.2.</span> <span class="toc-text">2. void 型指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%A9%BA%E6%8C%87%E9%92%88%E5%92%8C%E9%87%8E%E6%8C%87%E9%92%88"><span class="toc-number">3.3.</span> <span class="toc-text">3. 空指针和野指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E7%A9%BA%E6%8C%87%E9%92%88%E4%B8%8D%E6%8C%87%E5%90%91%E4%BB%BB%E4%BD%95%E4%B8%9C%E8%A5%BF%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.1 空指针：不指向任何东西的指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E9%87%8E%E6%8C%87%E9%92%88%E5%9C%B0%E5%9D%80%E5%B7%B2%E7%BB%8F%E5%A4%B1%E6%95%88%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.2 野指针：地址已经失效的指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B-%E6%8C%87%E5%90%91%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">4.</span> <span class="toc-text">四、指向不同数据类型的指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B0%E5%80%BC%E5%9E%8B%E6%8C%87%E9%92%88"><span class="toc-number">4.1.</span> <span class="toc-text">1. 数值型指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8C%87%E9%92%88"><span class="toc-number">4.2.</span> <span class="toc-text">2. 字符串指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E4%B8%8E%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88"><span class="toc-number">4.3.</span> <span class="toc-text">3. 指针数组与数组指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84"><span class="toc-number">4.3.1.</span> <span class="toc-text">3.1 指针数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88"><span class="toc-number">4.3.2.</span> <span class="toc-text">3.2 数组指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-number">4.4.</span> <span class="toc-text">4. 二维数组和指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88"><span class="toc-number">4.5.</span> <span class="toc-text">5. 结构体指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">4.6.</span> <span class="toc-text">6. 函数指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94-%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">五、总结</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2022/09/28/C-language-micro/" rel="bookmark" title="C++中碰到的那些宏">C++中碰到的那些宏</a></li><li><a href="/2022/10/23/construct/" rel="bookmark" title="C++继承-构造函数">C++继承-构造函数</a></li><li><a href="/2022/11/24/cv2%E6%8A%A5%E9%94%99%E5%A4%84%E7%90%86/" rel="bookmark" title="cv2报错处理">cv2报错处理</a></li><li><a href="/2023/01/23/cplus-use-gplus/" rel="bookmark" title="Linux环境下编译C++文件">Linux环境下编译C++文件</a></li><li><a href="/2023/03/12/vim-elementary-operations/" rel="bookmark" title="vim elementary operations">vim elementary operations</a></li><li><a href="/2023/03/13/c-%E4%B9%8B%E8%BF%B7%E6%83%91%E6%93%8D%E4%BD%9C/" rel="bookmark" title="c++之迷惑操作">c++之迷惑操作</a></li><li><a href="/2023/03/15/%E8%87%AA%E5%AE%9A%E4%B9%89map%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/" rel="bookmark" title="自定义map数据类型的比较函数的四种方法">自定义map数据类型的比较函数的四种方法</a></li><li><a href="/2023/03/28/cplusplus-mutable-keyword/" rel="bookmark" title="cplusplus中的mutable keyword">cplusplus中的mutable keyword</a></li><li><a href="/2023/05/25/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AF%87/" rel="bookmark" title="c++学习之内存管理篇">c++学习之内存管理篇</a></li><li><a href="/2023/06/02/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" rel="bookmark" title="内存管理">内存管理</a></li><li><a href="/2023/06/05/c%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="bookmark" title="c/c++强制类型转换">c/c++强制类型转换</a></li><li><a href="/2023/06/10/%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E4%BB%A5%E5%8F%8Aconst%E4%BD%BF%E7%94%A8/" rel="bookmark" title="指针常量与常量指针以及const使用">指针常量与常量指针以及const使用</a></li><li><a href="/2023/07/15/bash-shell/" rel="bookmark" title="bash-shell">bash-shell</a></li><li><a href="/2023/07/21/c-%E4%B8%8Etemplate%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/" rel="bookmark" title="c++的template简单使用">c++的template简单使用</a></li><li><a href="/2023/07/26/c-c-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="bookmark" title="c/c++强制类型转换">c/c++强制类型转换</a></li><li><a href="/2023/07/29/bash-shell%E7%BF%92%E9%A1%8C%E7%B7%B4%E7%BF%92%E5%A3%B9/" rel="bookmark" title="bash-shell習題練習壹">bash-shell習題練習壹</a></li><li><a href="/2023/07/29/bash-shell%E7%BF%92%E9%A1%8C%E7%B7%B4%E7%BF%92%E8%B2%B3/" rel="bookmark" title="bash-shell習題練貳">bash-shell習題練貳</a></li><li><a href="/2023/07/31/Linux%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/" rel="bookmark" title="Linux常用指令">Linux常用指令</a></li><li><a href="/2023/08/03/GDB%E8%B0%83%E8%AF%95/" rel="bookmark" title="GDB调试">GDB调试</a></li><li><a href="/2023/08/07/bash-shell-%E7%BF%92%E9%A1%8C%E7%B7%B4%E7%BF%92%E5%8F%81/" rel="bookmark" title="bash-shell習題練習叁">bash-shell習題練習叁</a></li><li><a href="/2023/08/11/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/" rel="bookmark" title="汇编语言入门教程">汇编语言入门教程</a></li><li><a href="/2023/08/15/x86%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E9%9B%86%E6%B1%87%E6%80%BB/" rel="bookmark" title="x86汇编指令集汇总">x86汇编指令集汇总</a></li><li class="active"><a href="/2023/08/15/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E8%AF%A6%E8%A7%A3/" rel="bookmark" title="C语言指针详解">C语言指针详解</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Percy Everard" data-src="/images/magic.png"><p class="name" itemprop="name">Percy Everard</p><div class="description" itemprop="description">Really start to record my life, no longer lazy!</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">79</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">7</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">67</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BlcmN5ZXZlcmFyZA==" title="https:&#x2F;&#x2F;github.com&#x2F;percyeverard"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvbXkvbS9tdXNpYy9wbGF5bGlzdD9pZD0yMjk0OTY3NTIy" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;my&#x2F;m&#x2F;music&#x2F;playlist?id&#x3D;2294967522"><i class="ic i-cloud-music"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmZlbmd5ZXBpYW9zYUAxNjMuY29t" title="mailto:fengyepiaosa@163.com"><i class="ic i-envelope"></i></span> <span class="exturl item instagram" data-url="aHR0cHM6Ly9pbnN0YWdyYW0uY29tL2NoYXJsZXNmZW5n" title="https:&#x2F;&#x2F;instagram.com&#x2F;charlesfeng"><i class="ic i-instagram"></i></span> <span class="exturl item blogger" data-url="aHR0cHM6Ly9jaGVycnlvYS5ibG9nc3BvdC5jb20v" title="https:&#x2F;&#x2F;cherryoa.blogspot.com&#x2F;"><i class="ic i-weibo"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-wenfeng"></i> </span><span class="author" itemprop="copyrightHolder">Percy Everard @ Percy Feng</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">211k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">3:12</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/08/15/C语言指针详解/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->